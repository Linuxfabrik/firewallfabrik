#!/bin/sh
#
#  This file is managed by FirewallFabrik - do not edit
#
#  FirewallFabrik fwf-nft VERSION
#
#  Generated TIMESTAMP
#
#  this object is used to test a configuration where firewall has dynamic address
#

FWBDEBUG=""

PATH="/sbin:/usr/sbin:/bin:/usr/bin:${PATH}"
export PATH

NFT="/usr/sbin/nft"

log() {
    echo "$1"
    which logger > /dev/null 2>&1 && logger -p info "$1"
}

check_nft() {
    if [ ! -x "$NFT" ]; then
        echo "Error: nft not found at $NFT"
        exit 1
    fi
}

prolog_commands() {
    echo "Running prolog script"

}

epilog_commands() {
    echo "Running epilog script"

}

run_epilog_and_exit() {
    epilog_commands
    exit "$1"
}

stop_action() {
    $NFT flush ruleset
}

block_action() {
    $NFT flush ruleset
    # block all traffic by default
    $NFT add table inet block
    $NFT add chain inet block input '{ type filter hook input priority 0; policy drop; }'
    $NFT add chain inet block forward '{ type filter hook forward priority 0; policy drop; }'
    $NFT add chain inet block output '{ type filter hook output priority 0; policy drop; }'
}

check_nft_status() {
    tables=$($NFT list tables 2>/dev/null)
    if [ -n "$tables" ]; then
        return 0
    fi
    return 3
}

status_action() {
    check_nft_status
    ret=$?
    if [ $ret -eq 0 ]; then
        return 0
    fi
    echo "Firewall is not configured"
    exit 3
}

script_body() {
    $NFT -f /dev/stdin <<'NFT_RULES'
flush ruleset

table ip filter {
    chain input {
        type filter hook input priority filter; policy drop;
        #
        # Rule 0 (eth1)
        #
        # Anti-spoofing rule
        iifname "eth1" ip saddr { 0.0.0.0, 192.168.1.1, 192.168.2.1, 222.222.222.222 } log level debug drop
        iifname "eth1" ip saddr 192.168.1.0/24 log level debug drop
        #
        # Rule 2 (eth1)
        #
        iifname "eth1" ip saddr != 192.168.2.0/24 icmp type 8 code 0 log level debug drop
        #
        # Rule 3 (eth1)
        #
        iifname "eth1" tcp dport 22 ct state new accept
        #
        # Rule 4 (eth1)
        #
        iifname "eth1" icmp type 8 code 0 log level debug drop
        #
        # Rule 6 (global)
        #
        # INTPUT with "-i +"
        # the "-i +" option is redundant if chain is INPUT,
        # it should be removed by optimization
        ip saddr 1.1.1.1 accept
        #
        # Rule 11 (global)
        #
        ip saddr != { 192.168.1.10, 192.168.1.20 } icmp type 3 log level debug drop
        #
        # Rule 15 (global)
        #
        # should permit access to all
        # addresses that belong to
        # the firewall, but not to those
        # that are used in NAT rules
        # and are added as virtual
        # addresses
        tcp dport 25 ct state new accept
        #
        # Rule 17 (global)
        #
        # 'masquerading' rule
        ip saddr 192.168.1.0/24 ct state new accept
        #
        # Rule 18 (global)
        #
        ip saddr 192.168.1.0/24 ip daddr != { 0.0.0.0, 192.168.1.1, 192.168.2.1, 222.222.222.222 } ct state new accept
        #
        # Rule 19 (global)
        #
        # 'catch all' rule
        log level debug drop
    }

    chain forward {
        type filter hook forward priority filter; policy drop;
        #
        # Rule 0 (eth1)
        #
        # Anti-spoofing rule
        iifname "eth1" ip saddr { 0.0.0.0, 192.168.1.1, 192.168.2.1, 222.222.222.222 } log level debug drop
        iifname "eth1" ip saddr 192.168.1.0/24 log level debug drop
        #
        # Rule 1 (eth1)
        #
        # Anti-spoofing rule
        oifname "eth1" ip saddr != 192.168.1.0/24 log level debug drop
        #
        # Rule 2 (eth1)
        #
        iifname "eth1" ip saddr != 192.168.2.0/24 icmp type 8 code 0 log level debug drop
        oifname "eth1" ip saddr != 192.168.2.0/24 icmp type 8 code 0 log level debug drop
        #
        # Rule 4 (eth1)
        #
        iifname "eth1" icmp type 8 code 0 log level debug drop
        oifname "eth1" icmp type 8 code 0 log level debug drop
        #
        # Rule 7 (global)
        #
        # OUTPUT + FORWARD
        ip daddr 1.1.1.1 accept
        #
        # Rule 8 (global)
        #
        # INPUT + FORWARD
        ip saddr 1.1.1.1 accept
        #
        # Rule 12 (global)
        #
        # testing negation in the policy rule
        ip saddr != { 192.168.1.10, 192.168.1.20 } icmp type 3 log level debug drop
        #
        # Rule 13 (global)
        #
        # testing negation in service field
        ip daddr { 192.168.1.10, 192.168.1.20 } tcp dport != { 25, 22 } log level debug drop
        #
        # Rule 14 (global)
        #
        ip daddr 192.168.1.10 tcp dport 25 log level debug drop
        #
        # Rule 17 (global)
        #
        # 'masquerading' rule
        ip saddr 192.168.1.0/24 ct state new accept
        #
        # Rule 19 (global)
        #
        # 'catch all' rule
        log level debug drop
    }

    chain output {
        type filter hook output priority filter; policy drop;
        #
        # Rule 1 (eth1)
        #
        # Anti-spoofing rule
        oifname "eth1" ip saddr != { 0.0.0.0, 192.168.1.1, 192.168.2.1, 222.222.222.222 } log level debug drop
        oifname "eth1" ip saddr != 192.168.1.0/24 log level debug drop
        #
        # Rule 2 (eth1)
        #
        oifname "eth1" ip saddr != 192.168.2.0/24 icmp type 8 code 0 log level debug drop
        #
        # Rule 4 (eth1)
        #
        oifname "eth1" icmp type 8 code 0 log level debug drop
        #
        # Rule 5 (global)
        #
        # OUTPUT
        ip daddr 1.1.1.1 accept
        #
        # Rule 11 (global)
        #
        ip saddr != { 192.168.1.10, 192.168.1.20 } ip daddr { 0.0.0.0, 192.168.1.1, 192.168.2.1, 222.222.222.222 } icmp type 3 log level debug drop
        #
        # Rule 12 (global)
        #
        # testing negation in the policy rule
        ip saddr != { 192.168.1.10, 192.168.1.20 } icmp type 3 log level debug drop
        #
        # Rule 13 (global)
        #
        # testing negation in service field
        ip daddr { 192.168.1.10, 192.168.1.20 } tcp dport != { 25, 22 } log level debug drop
        #
        # Rule 14 (global)
        #
        ip daddr 192.168.1.10 tcp dport 25 log level debug drop
        #
        # Rule 15 (global)
        #
        # should permit access to all
        # addresses that belong to
        # the firewall, but not to those
        # that are used in NAT rules
        # and are added as virtual
        # addresses
        ip daddr { 0.0.0.0, 192.168.1.1, 192.168.2.1, 222.222.222.222 } tcp dport 25 ct state new accept
        #
        # Rule 17 (global)
        #
        # 'masquerading' rule
        ip saddr 192.168.1.0/24 ct state new accept
        #
        # Rule 19 (global)
        #
        # 'catch all' rule
        log level debug drop
    }
}

table ip nat {
    chain prerouting {
        type nat hook prerouting priority dstnat;
        #
        # Rule 5 (NAT)
        #
        ip daddr 192.168.1.1 tcp dport 22 dnat to 192.168.1.10:22
        #
        # Rule 6 (NAT)
        #
        ip daddr 0.0.0.0 tcp dport 22 dnat to 192.168.1.10:22
    }

    chain postrouting {
        type nat hook postrouting priority srcnat;
        #
        # Rule 0 (NAT)
        #
        oifname "eth0" ip saddr 192.168.1.10 snat to 192.168.1.1
        oifname "eth1" ip saddr 192.168.1.10 snat to 192.168.1.1
        oifname "eth2" ip saddr 192.168.1.10 snat to 192.168.1.1
        oifname "eth3" ip saddr 192.168.1.10 snat to 192.168.1.1
        #
        # Rule 1 (NAT)
        #
        oifname "eth0" ip saddr 192.168.1.10 snat to 222.222.222.40
        oifname "eth1" ip saddr 192.168.1.10 snat to 222.222.222.40
        oifname "eth2" ip saddr 192.168.1.10 snat to 222.222.222.40
        oifname "eth3" ip saddr 192.168.1.10 snat to 222.222.222.40
        #
        # Rule 2 (NAT)
        #
        oifname "eth0" ip saddr 192.168.1.10 snat to 222.222.222.40
        oifname "eth1" ip saddr 192.168.1.10 snat to 222.222.222.40
        oifname "eth2" ip saddr 192.168.1.10 snat to 222.222.222.40
        oifname "eth3" ip saddr 192.168.1.10 snat to 222.222.222.40
        #
        # Rule 3 (NAT)
        #
        oifname "eth0" ip saddr 192.168.1.0/24 ip daddr 192.168.2.0/24 snat to 192.168.1.1
        oifname "eth1" ip saddr 192.168.1.0/24 ip daddr 192.168.2.0/24 snat to 192.168.1.1
        oifname "eth2" ip saddr 192.168.1.0/24 ip daddr 192.168.2.0/24 snat to 192.168.1.1
        oifname "eth3" ip saddr 192.168.1.0/24 ip daddr 192.168.2.0/24 snat to 192.168.1.1
        #
        # Rule 4 (NAT)
        #
        oifname "eth1" ip saddr 192.168.1.0/24 snat to 0.0.0.0
        oifname "eth1" ip saddr 192.168.1.1 snat to 0.0.0.0
    }
}

NFT_RULES
}

ip_forward() {
    :

}

# See how we were called.
# For backwards compatibility missing argument is equivalent to 'start'

cmd=$1
test -z "$cmd" && {
    cmd="start"
}

case "$cmd" in
    start)
        log "Activating firewall script generated TIMESTAMP"
        check_nft
        prolog_commands
        stop_action
        script_body
        ip_forward
        epilog_commands
        RETVAL=$?
        ;;

    stop)
        stop_action
        RETVAL=$?
        ;;

    status)
        status_action
        RETVAL=$?
        ;;

    block)
        block_action
        RETVAL=$?
        ;;

    reload)
        $0 stop
        $0 start
        RETVAL=$?
        ;;

    *)
        echo "Usage $0 [start|stop|status|block|reload]"
        ;;

esac

exit "$RETVAL"
